<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Dataflow programming :: Red Planet Labs Documentation</title>
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../_/css/site.css">
<!-- Google tag (gtag.js) -->
<script async="" src="//cse.google.com/adsense/search/async-ads.js"></script><script type="text/javascript" async="" src="https://www.googletagmanager.com/gtag/js?id=G-6FCG0W0TYJ&amp;l=dataLayer&amp;cx=c&amp;gtm=457e53h1za200&amp;tag_exp=102482433~102587591~102717422~102788824~102813109~102814060~102825837~102879719"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-137231341-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-6FCG0W0TYJ');
</script>
  <script src="https://www.google.com/cse/static/element/75c56d121cde450a/cse_element__en.js?usqp=CAM%3D" type="text/javascript"></script><link type="text/css" href="https://www.google.com/cse/static/element/75c56d121cde450a/default+en.css" rel="stylesheet"><link type="text/css" href="https://www.google.com/cse/static/style/look/v4/default.css" rel="stylesheet"><style type="text/css">.gsc-control-cse{font-family:arial, sans-serif}.gsc-control-cse .gsc-table-result{font-family:arial, sans-serif}.gsc-refinementsGradient{background:linear-gradient(to left,rgba(255,255,255,1),rgba(255,255,255,0))}.gsc-control-cse{border-color:#1a1a1a;background-color:#1a1a1a}input.gsc-input,.gsc-input-box,.gsc-input-box-hover,.gsc-input-box-focus{border-color:#DFE1E5}.gsc-search-button-v2,.gsc-search-button-v2:hover,.gsc-search-button-v2:focus{border-color:#3079ED;background-color:#4D90FE;background-image:none;filter:none}.gsc-search-button-v2 svg{fill:#FFFFFF}.gsc-tabHeader.gsc-tabhActive,.gsc-refinementHeader.gsc-refinementhActive{color:#1A73E8;border-color:#1A73E8;background-color:#FFFFFF}.gsc-tabHeader.gsc-tabhInactive,.gsc-refinementHeader.gsc-refinementhInactive{color:#666666;border-color:#666666;background-color:#FFFFFF}.gsc-webResult.gsc-result,.gsc-results .gsc-imageResult{border-color:#FFFFFF;background-color:#FFFFFF}.gsc-webResult.gsc-result:hover{border-color:#FFFFFF;background-color:#FFFFFF}.gs-webResult.gs-result a.gs-title:link,.gs-webResult.gs-result a.gs-title:link b,.gs-imageResult a.gs-title:link,.gs-imageResult a.gs-title:link b{color:#1155CC}.gs-webResult.gs-result a.gs-title:visited,.gs-webResult.gs-result a.gs-title:visited b,.gs-imageResult a.gs-title:visited,.gs-imageResult a.gs-title:visited b{color:#1155CC}.gs-webResult.gs-result a.gs-title:hover,.gs-webResult.gs-result a.gs-title:hover b,.gs-imageResult a.gs-title:hover,.gs-imageResult a.gs-title:hover b{color:#1155CC}.gs-webResult.gs-result a.gs-title:active,.gs-webResult.gs-result a.gs-title:active b,.gs-imageResult a.gs-title:active,.gs-imageResult a.gs-title:active b{color:#1155CC}.gsc-cursor-page{color:#1155CC}a.gsc-trailing-more-results:link{color:#1155CC}.gs-webResult:not(.gs-no-results-result):not(.gs-error-result) .gs-snippet,.gs-fileFormatType{color:#333333}.gs-webResult div.gs-visibleUrl{color:#009933}.gs-webResult div.gs-visibleUrl-short{color:#009933}.gs-webResult div.gs-visibleUrl-short{display:none}.gs-webResult div.gs-visibleUrl-long{display:none}.gs-webResult div.gs-visibleUrl-breadcrumb{display:block}.gs-promotion div.gs-visibleUrl-short{display:none}.gs-promotion div.gs-visibleUrl-long{display:block}.gs-promotion div.gs-visibleUrl-breadcrumb{display:none}.gsc-cursor-box{border-color:#FFFFFF}.gsc-results .gsc-cursor-box .gsc-cursor-page{border-color:#666666;background-color:#FFFFFF;color:#666666}.gsc-results .gsc-cursor-box .gsc-cursor-current-page{border-color:#1A73E8;background-color:#FFFFFF;color:#1A73E8}.gsc-webResult.gsc-result.gsc-promotion{border-color:#FFFFFF;background-color:#F6F6F6}.gsc-completion-title{color:#1155CC}.gsc-completion-snippet{color:#333333}.gs-promotion a.gs-title:link,.gs-promotion a.gs-title:link *,.gs-promotion .gs-snippet a:link{color:#1155CC}.gs-promotion a.gs-title:visited,.gs-promotion a.gs-title:visited *,.gs-promotion .gs-snippet a:visited{color:#1155CC}.gs-promotion a.gs-title:hover,.gs-promotion a.gs-title:hover *,.gs-promotion .gs-snippet a:hover{color:#1155CC}.gs-promotion a.gs-title:active,.gs-promotion a.gs-title:active *,.gs-promotion .gs-snippet a:active{color:#1155CC}.gs-promotion .gs-snippet,.gs-promotion .gs-title .gs-promotion-title-right,.gs-promotion .gs-title .gs-promotion-title-right *{color:#333333}.gs-promotion .gs-visibleUrl,.gs-promotion .gs-visibleUrl-short{color:#009933}.gcsc-find-more-on-google{color:#1155CC}.gcsc-find-more-on-google-magnifier{fill:#1155CC}</style><style type="text/css">.gscb_a{display:inline-block;font:27px/13px arial,sans-serif}.gsst_a .gscb_a{color:#a1b9ed;cursor:pointer}.gsst_a:hover .gscb_a,.gsst_a:focus .gscb_a{color:#36c}.gsst_a{display:inline-block}.gsst_a{cursor:pointer;padding:0 4px}.gsst_a:hover{text-decoration:none!important}.gsst_b{font-size:16px;padding:0 2px;position:relative;user-select:none;-webkit-user-select:none;white-space:nowrap}.gsst_e{vertical-align:middle;opacity:0.55;}.gsst_a:hover .gsst_e,.gsst_a:focus .gsst_e{opacity:0.72;}.gsst_a:active .gsst_e{opacity:1;}.gsst_f{background:white;text-align:left}.gsst_g{background-color:white;border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-webkit-box-shadow:0 2px 4px rgba(0,0,0,0.2);margin:-1px -3px;padding:0 6px}.gsst_h{background-color:white;height:1px;margin-bottom:-1px;position:relative;top:-1px}.gsib_a{width:100%;padding:4px 6px 0}.gsib_a,.gsib_b{vertical-align:top}.gssb_c{border:0;position:absolute;z-index:989}.gssb_e{border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-webkit-box-shadow:0 2px 4px rgba(0,0,0,0.2);cursor:default}.gssb_f{visibility:hidden;white-space:nowrap}.gssb_k{border:0;display:block;position:absolute;top:0;z-index:988}.gsdd_a{border:none!important}.gsq_a{padding:0}.gssb_a{padding:0 7px}.gssb_a,.gssb_a td{white-space:nowrap;overflow:hidden;line-height:22px}#gssb_b{font-size:11px;color:#36c;text-decoration:none}#gssb_b:hover{font-size:11px;color:#36c;text-decoration:underline}.gssb_g{text-align:center;padding:8px 0 7px;position:relative}.gssb_h{font-size:15px;height:28px;margin:0.2em;-webkit-appearance:button}.gssb_i{background:#eee}.gss_ifl{visibility:hidden;padding-left:5px}.gssb_i .gss_ifl{visibility:visible}a.gssb_j{font-size:13px;color:#36c;text-decoration:none;line-height:100%}a.gssb_j:hover{text-decoration:underline}.gssb_l{height:1px;background-color:#e5e5e5}.gssb_m{color:#000;background:#fff}.gssb_a{padding:0 9px}.gsib_a{padding:5px 9px 4px 9px}.gscb_a{line-height:27px}.gssb_e{border:0}.gssb_l{margin:5px 0}input.gsc-input::-webkit-input-placeholder{font-size:14px}input.gsc-input:-moz-placeholder{font-size:14px}input.gsc-input::-moz-placeholder{font-size:14px}input.gsc-input:-ms-input-placeholder{font-size:14px}input.gsc-input:focus::-webkit-input-placeholder{color:transparent}input.gsc-input:focus:-moz-placeholder{color:transparent}input.gsc-input:focus::-moz-placeholder{color:transparent}input.gsc-input:focus:-ms-input-placeholder{color:transparent}.gssb_c .gsc-completion-container{position:static}.gssb_c{z-index:5000}.gsc-completion-container table{background:transparent;font-size:inherit;font-family:inherit}.gssb_c > tbody > tr,.gssb_c > tbody > tr > td,.gssb_d,.gssb_d > tbody > tr,.gssb_d > tbody > tr > td,.gssb_e,.gssb_e > tbody > tr,.gssb_e > tbody > tr > td{padding:0;margin:0;border:0}.gssb_a table,.gssb_a table tr,.gssb_a table tr td{padding:0;margin:0;border:0}</style></head>
  <body class="article">
<style>
  p {
    hyphens: none;
  }
  td {
    hyphens: none;
  }

  p code {
    background: #eeeeee !important
  }

  .gsc-clear-button {
    display: none;
  }

  .gsc-control-cse {
    font-size: 10px !important
  }
</style>
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="/docs/~/index.html">Red Planet Labs Documentation</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <script async="" src="https://cse.google.com/cse.js?cx=a198d0f9938004cd4">
          </script>
          <div id="___gcse_0"><div class="gsc-control-cse gsc-control-cse-en"><div class="gsc-control-wrapper-cse" dir="ltr"><form class="gsc-search-box gsc-search-box-tools" accept-charset="utf-8"><table cellspacing="0" cellpadding="0" role="presentation" class="gsc-search-box"><tbody><tr><td class="gsc-input"><div class="gsc-input-box" id="gsc-iw-id1"><table cellspacing="0" cellpadding="0" role="presentation" id="gs_id50" class="gstl_50 gsc-input" style="width: 100%; padding: 0px;"><tbody><tr><td id="gs_tti50" class="gsib_a"><input autocomplete="off" type="text" size="10" class="gsc-input" name="search" title="search" aria-label="search" id="gsc-i-id1" dir="ltr" spellcheck="false" style="width: 100%; padding: 0px; border: none; margin: 0px; height: auto; outline: none;"></td><td class="gsib_b"><div class="gsst_b" id="gs_st50" dir="ltr"><a class="gsst_a" href="javascript:void(0)" title="Clear search box" role="button" style="display: none;"><span class="gscb_a" id="gs_cb50" aria-hidden="true">Ã—</span></a></div></td></tr></tbody></table></div></td><td class="gsc-search-button"><button class="gsc-search-button gsc-search-button-v2"><svg width="13" height="13" viewBox="0 0 13 13"><title>search</title><path d="m4.8495 7.8226c0.82666 0 1.5262-0.29146 2.0985-0.87438 0.57232-0.58292 0.86378-1.2877 0.87438-2.1144 0.010599-0.82666-0.28086-1.5262-0.87438-2.0985-0.59352-0.57232-1.293-0.86378-2.0985-0.87438-0.8055-0.010599-1.5103 0.28086-2.1144 0.87438-0.60414 0.59352-0.8956 1.293-0.87438 2.0985 0.021197 0.8055 0.31266 1.5103 0.87438 2.1144 0.56172 0.60414 1.2665 0.8956 2.1144 0.87438zm4.4695 0.2115 3.681 3.6819-1.259 1.284-3.6817-3.7 0.0019784-0.69479-0.090043-0.098846c-0.87973 0.76087-1.92 1.1413-3.1207 1.1413-1.3553 0-2.5025-0.46363-3.4417-1.3909s-1.4088-2.0686-1.4088-3.4239c0-1.3553 0.4696-2.4966 1.4088-3.4239 0.9392-0.92727 2.0864-1.3969 3.4417-1.4088 1.3553-0.011889 2.4906 0.45771 3.406 1.4088 0.9154 0.95107 1.379 2.0924 1.3909 3.4239 0 1.2126-0.38043 2.2588-1.1413 3.1385l0.098834 0.090049z"></path></svg></button></td><td class="gsc-clear-button"><div class="gsc-clear-button" title="clear results">&nbsp;</div></td></tr></tbody></table></form><div class="gsc-results-wrapper-overlay"><div class="gsc-results-close-btn" tabindex="0"></div><div class="gsc-positioningWrapper"><div class="gsc-tabsAreaInvisible"><div aria-label="refinement" role="tab" class="gsc-tabHeader gsc-inline-block gsc-tabhActive">Custom Search</div><span class="gs-spacer"> </span></div></div><div class="gsc-positioningWrapper"><div class="gsc-refinementsAreaInvisible"></div></div><div class="gsc-above-wrapper-area-invisible"><div class="gsc-above-wrapper-area-backfill-container"></div><table cellspacing="0" cellpadding="0" role="presentation" class="gsc-above-wrapper-area-container"><tbody><tr><td class="gsc-result-info-container"><div class="gsc-result-info-invisible"></div></td><td class="gsc-orderby-container"><div class="gsc-orderby-invisible"><div class="gsc-orderby-label gsc-inline-block">Sort by:</div><div class="gsc-option-menu-container gsc-inline-block"><div class="gsc-selected-option-container gsc-inline-block"><div class="gsc-selected-option">Relevance</div><div class="gsc-option-selector"></div></div><div class="gsc-option-menu-invisible"><div class="gsc-option-menu-item gsc-option-menu-item-highlighted"><div class="gsc-option">Relevance</div></div><div class="gsc-option-menu-item"><div class="gsc-option">Date</div></div></div></div></div></td></tr></tbody></table></div><div class="gsc-adBlockInvisible"></div><div class="gsc-wrapper"><div class="gsc-adBlockInvisible"></div><div class="gsc-resultsbox-invisible"><div class="gsc-resultsRoot gsc-tabData gsc-tabdActive"><div><div class="gsc-expansionArea"></div></div></div></div></div></div><div class="gsc-modal-background-image" tabindex="0"></div></div></div></div>
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs" data-version="~">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style=""></button>
    <h3 class="title"><a href="index.html">Documentation</a></h3>
<ul class="nav-list">
  <li class="nav-item is-active is-current-path" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="why-use-rama.html">Why use Rama?</a>
  </li>
  <li class="nav-item is-active is-current-path" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="tutorial1.html">Tutorial</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="tutorial1.html">First module</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="tutorial2.html">Depots, ETLs, and PStates</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="tutorial3.html">Distributed programming</a>
  </li>
  <li class="nav-item is-current-page is-active" data-depth="2">
    <a class="nav-link" href="tutorial4.html">Dataflow programming</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="tutorial5.html">Types of ETLs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="tutorial6.html">Tying it all together</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="downloads-maven-local-dev.html">Downloads, Maven, and local development</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="terminology.html">Terminology</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="paths.html">Paths</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="intermediate-dataflow.html">Intermediate dataflow programming</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="aggregators.html">Aggregators</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="stream.html">Stream topologies</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="microbatch.html">Microbatch topologies</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="query.html">Query topologies</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="depots.html">Depots</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="pstates.html">PStates</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="partitioners.html">Partitioners</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="serialization.html">Custom serialization</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="module-dependencies.html">Dependencies between modules</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="operating-rama.html">Operating Rama clusters</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="heterogenous-clusters.html">Heterogenous clusters</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="replication.html">Replication</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="backups.html">Backups</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="acid.html">ACID semantics</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="rest.html">REST API</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="integrating.html">Integrating with other tools</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="all-configs.html">All configs</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing.html">Testing</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="clj-defining-modules.html">Clojure API</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="clj-defining-modules.html">Defining and using modules</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="clj-dataflow-lang.html">Dataflow language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="clj-serialization.html">Custom serialization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="clj-testing.html">Testing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Documentation</span>
    <span class="version">~</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="index.html">Documentation</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">~</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Documentation</a></li>
    <li><a href="tutorial1.html">Tutorial</a></li>
    <li><a href="tutorial4.html">Dataflow programming</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"><h3>Contents</h3><ul><li data-level="1"><a href="#_the_dataflow_programming_paradigm" class="">The dataflow programming paradigm</a></li><li data-level="1"><a href="#_operations_input_and_output" class="">Operations, input and output</a></li><li data-level="1"><a href="#_dataflow_in_rama" class="">Dataflow in Rama</a></li><li data-level="2"><a href="#_variable_scope" class="">Variable scope</a></li><li data-level="2"><a href="#_performance" class="">Performance</a></li><li data-level="1"><a href="#_a_quick_aside_on_execute" class="">A quick aside on execute()</a></li><li data-level="1"><a href="#_branching_dataflow_graphs" class="">Branching dataflow graphs</a></li><li data-level="2"><a href="#_output_streams_hooks_anchors_and_unify" class="">Output streams, hooks, anchors, and unify</a></li><li data-level="2"><a href="#_unifying_dataflow_branches" class="">Unifying dataflow branches</a></li><li data-level="1"><a href="#_conditionals" class="is-active">Conditionals</a></li><li data-level="1"><a href="#_writing_custom_operations">Writing custom operations</a></li><li data-level="1"><a href="#_immutable_scope_and_shadowing">Immutable scope and shadowing</a></li><li data-level="1"><a href="#_looping">Looping</a></li><li data-level="1"><a href="#_looping_without_vars">Looping without vars</a></li><li data-level="1"><a href="#_summary">Summary</a></li></ul></div>
</aside>
<article class="doc">
<h1 class="page">Dataflow programming</h1>
<aside class="toc embedded"><div class="toc-menu"><h3>Contents</h3><ul><li data-level="1"><a href="#_the_dataflow_programming_paradigm">The dataflow programming paradigm</a></li><li data-level="1"><a href="#_operations_input_and_output">Operations, input and output</a></li><li data-level="1"><a href="#_dataflow_in_rama">Dataflow in Rama</a></li><li data-level="2"><a href="#_variable_scope">Variable scope</a></li><li data-level="2"><a href="#_performance">Performance</a></li><li data-level="1"><a href="#_a_quick_aside_on_execute">A quick aside on execute()</a></li><li data-level="1"><a href="#_branching_dataflow_graphs">Branching dataflow graphs</a></li><li data-level="2"><a href="#_output_streams_hooks_anchors_and_unify">Output streams, hooks, anchors, and unify</a></li><li data-level="2"><a href="#_unifying_dataflow_branches">Unifying dataflow branches</a></li><li data-level="1"><a href="#_conditionals">Conditionals</a></li><li data-level="1"><a href="#_writing_custom_operations">Writing custom operations</a></li><li data-level="1"><a href="#_immutable_scope_and_shadowing">Immutable scope and shadowing</a></li><li data-level="1"><a href="#_looping">Looping</a></li><li data-level="1"><a href="#_looping_without_vars">Looping without vars</a></li><li data-level="1"><a href="#_summary">Summary</a></li></ul></div></aside><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>To perform work in Rama, you write ETL and query topologies using Ramaâ€™s
<em>dataflow API</em>. This chapter will explain the dataflow programming paradigm that
the API embodies, and it will show you how to use all the elements of the
API.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_dataflow_programming_paradigm"><a class="anchor" href="#_the_dataflow_programming_paradigm"></a>The dataflow programming paradigm</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dataflow programming can be understood in contrast to imperative programming,
the industry-dominant paradigm that you probably have experience with.</p>
</div>
<div class="paragraph">
<p>You can think of imperative programming as defining a sequence of instructions
to a worker for them to carry out: add these numbers, assign the result to this
variable, call this method. You can see this physically embodied in something
like a robot, where commands direct the robotâ€™s behavior: turn to the right, walk forward
four feet, turn to the left.</p>
</div>
<div class="paragraph">
<p>By contrast, dataflow programming is like constructing an assembly line. Each
worker on the line waits for an input, performs an operation on it, and sends
zero or more outputs to zero or more other workers. You can represent the
relationships between workers as a directed graph, and you can refer to this
graph as a <em>dataflow pipeline</em>. In Rama, we call these graphs <em>topologies</em>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/diagrams/dataflow-diagrams/basic-dataflow-graph.png" alt="basic dataflow graph">
</div>
</div>
<div class="paragraph">
<p>Dataflow programming can feel weird at first. Our usual way of
constructing work is to give a kind of ontological primacy to subjects over
verbs. Itâ€™s natural to think of the world as consisting of agents performing actions rather
than as processes that entities flow through. It somehow feels more natural to
think of a robot carrying out commands then it does to think of a network of
nodes modifying data as it "flows" through.</p>
</div>
<div class="paragraph">
<p>Weird or not, itâ€™s a great model for distributed programming.  Dataflow is an extremely
expressive way to map code to multiple cores or machines, which is why the Rama topology API
was created.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operations_input_and_output"><a class="anchor" href="#_operations_input_and_output"></a>Operations, input and output</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once again, we can understand the dataflow paradigm by comparing it to the
imperative paradigm.</p>
</div>
<div class="paragraph">
<p>When an imperative program runs, its main thread of execution will start by
calling some method (or function if youâ€™re not using an OO language; since Rama
is built on Java, letâ€™s stick to talking about methods). Letâ€™s call this <code>Method
A</code>. <code>Method A</code> might in turn call <code>Method B</code>, which calls <code>Method C</code>, and so
forth. Eventually, each of the method calls in this nested chain will return a
value, until <code>Method A</code> returns a value. The main thread of execution will then
move forward and call the next method, <code>Method A'</code>, and the same process will
play out.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/diagrams/dataflow-diagrams/basic-function-call.png" alt="basic function call">
</div>
</div>
<div class="paragraph">
<p>Our mental model for an imperative program consists of <em>caller</em> methods
coordinating with <em>callee</em> methods by passing in arguments and waiting for a
single return value. This relationship is so ingrained that we can take it for
granted. In fact, it may feel strange to draw attention to it or to refer to the
relationship as "coordination", but itâ€™s helpful to look at it that way
because it helps with understanding the dataflow paradigm.</p>
</div>
<div class="paragraph">
<p>On an abstract level, the process of programming involves decomposing a system
into functional units like methods, and then getting those units to coordinate
in some way. With imperative languages, that coordination happens via the
callstack. Because it happens implicitly, and because itâ€™s so pervasive, itâ€™s
easy to gain the sense that itâ€™s "the" way that programs work.</p>
</div>
<div class="paragraph">
<p>However, itâ€™s not the only way for you to coordinate functional units. In a
dataflow program, you think in terms of <em>operations</em> that wait for input. Upon
receiving input, they perform some work and emit output values to one or more
other operations.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/diagrams/dataflow-diagrams/operations.png" alt="operations">
</div>
</div>
<div class="paragraph">
<p>The corresponding program could be written so that when <code>Operation A</code> receives
an input, it emits two output values to <code>Operation B</code> and one output value
<code>Operation C</code>. <code>Operation B</code> would perform its work for each of the two inputs
it receives, and <code>Operation C</code> would perform its work the single value it
receives. These operations donâ€™t return a value to <code>Operation A</code>.</p>
</div>
<div class="paragraph">
<p>There are already some pronounced differences with an imperative program:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In an imperative program, thereâ€™s a tight coupling between <em>what</em> gets done
and <em>how</em> it happens: a main execution thread drives the process. In a
dataflow program, the mapping between operations and threads is an
implementation detail.</p>
</li>
<li>
<p>Dataflow programs are <em>reactive</em> in a way that imperative programs are not.
The operations in a dataflow graph fire in response to receiving input.</p>
</li>
<li>
<p>In an imperative program, coordination between a method and its caller
happens by <em>returning</em> a single value to the caller. In a dataflow program,
an operation can <em>emit</em> multiple values to multiple operations.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dataflow_in_rama"><a class="anchor" href="#_dataflow_in_rama"></a>Dataflow in Rama</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So in dataflow programs, you construct a computation graph where each node
receives input and emits output values to other nodes. How does this all work in
Rama? How do you specify the structure of the dataflow graph, and how do you
specify the operations for each node?</p>
</div>
<div class="paragraph">
<p>These two questions are intertwined, but letâ€™s start by focusing on how to
specify the graph structure. (As we specify the graph, weâ€™ll also specify the
nodes' operations by using Ramaâ€™s built-in operations, but soon youâ€™ll see
how to write operations of your own.)</p>
</div>
<div class="paragraph">
<p>The examples weâ€™ll look at will be very simple. Theyâ€™ll be disconnected from modules and ETLs so that you can focus just on the dataflow machinery. The following code can be run from any Java process just with Rama on the classpath as a library. You can also try these examples in a Groovy shell â€“ Groovy is similar enough to Java that these examples can be run in Groovy without changes. As a reminder, to launch a Groovy shell from <a href="https://github.com/redplanetlabs/rama-examples">rama-examples</a> run <code>mvn compile gplus:shell</code>.</p>
</div>
<div class="paragraph">
<p>Hereâ€™s the first example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">singleNode</span><span class="hljs-params">()</span> </span>{
    Block.each(Ops.PRINTLN, <span class="hljs-number">10</span>).execute();
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>To run this in a Groovy shell, enter the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">groovy:000&gt; import com.rpl.rama.Block;
groovy:000&gt; import com.rpl.rama.ops.Ops;
groovy:000&gt; Block.each(Ops.PRINTLN, 10).execute();</code></pre>
<div class="source-toolbox"><span class="source-lang">shell</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>We create a dataflow graph consisting of one node. Then we <code>execute</code> it, printing the number <code>10</code>.</p>
</div>
<div class="paragraph">
<p>How does this work? <code>Block.each()</code> establishes a new dataflow graph and creates
a single node in it; in general, <code>each()</code> will append a node. You can think of
it as meaning, "Each time this node receives input, execute the given operation
with the given arguments." In this case, the given operation is <code>Ops.PRINTLN</code>, and
the argument is <code>10</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/diagrams/dataflow-diagrams/one-node-example.png" alt="one node example">
</div>
</div>
<div class="paragraph">
<p>The Rama API follows the builder pattern, so that when you call the <code>.each()</code>
method it returns a value that you can use to chain methods and further build up
the dataflow graph, or (as in the case of this example) call the <code>execute()</code>
method.</p>
</div>
<div class="paragraph">
<p>You can think of <code>execute()</code> as "send an input to this dataflow graph". The
input is empty, but nevertheless the behavior of the dataflow graph is "execute
the given operation on every input". Therefore, the <code>Ops.PRINTLN</code> operation runs
and prints 10.</p>
</div>
<div class="sect2">
<h3 id="_variable_scope"><a class="anchor" href="#_variable_scope"></a>Variable scope</h3>
<div class="paragraph">
<p>Letâ€™s look at another example. This example will help you understand how the Rama
API connects nodes, as well as how Rama handles scope:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Block.each(Ops.IDENTITY, <span class="hljs-string">"a"</span>).out(<span class="hljs-string">"*x"</span>)
     .each(Ops.PRINTLN, <span class="hljs-string">"*x"</span>)
     .execute();</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>In this example, we create a dataflow graph with multiple nodes. Each call to
<code>each()</code> creates a node, just as before, and the call to <code>out()</code> creates a node
too. If you were to walk through the graphâ€™s construction step by step, this is
what happens:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a node that performs the <code>Ops.IDENTITY</code> operation with the argument
<code>"a"</code> for each input.</p>
</li>
<li>
<p>Connect this node with a node for <code>out("*x")</code> (Youâ€™ll see what <code>out("*x")</code> does in a second).</p>
</li>
<li>
<p>Create another node that performs the operation <code>Ops.PRINTLN</code>. When <code>out("*x")</code> emits a value, the
node for <code>each(Ops.PRINTLN, "*x")</code> receives it as input.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/diagrams/dataflow-diagrams/println-example.png" alt="println example">
</div>
</div>
<div class="paragraph">
<p>In general, as you chain calls to <code>each</code> and <code>out</code>, you construct a linear
dataflow graph. The output of one node becomes the input to the next.</p>
</div>
<div class="paragraph">
<p>Thereâ€™s something interesting happening here: the first node emits the string
<code>"a"</code>, and the third node is able to read this value. This is possible because
Ramaâ€™s dataflow nodes also receive a <em>scope</em> as an implicit input value,
and <code>out</code> updates this scope. When <code>each(Ops.IDENTITY, "a")</code> emits the string
<code>"a"</code>, the node <code>out("*x")</code> receives <code>"a"</code> as input along with an empty scope.
<code>out</code> updates the scope, assigning <code>"a"</code> to the identifier <code>"*x"</code>. We call these
scoped bindings <em>vars</em>; <code>"*x"</code> refers to a var.</p>
</div>
<div class="paragraph">
<p>Thus, when the next nodeâ€‰â€”â€‰<code>each(Ops.PRINTLN, "*x")</code>â€‰â€”â€‰receives its input, the
string <code>"a"</code> is included, bound to the identifier <code>"*x"</code> in the inputâ€™s scope.
When you include a string with a <code>"*"</code> or <code>"$$"</code> prefix in the argument list to
<code>each</code>, Ramaâ€™s behavior is to look up the corresponding value in the scope and
use that when performing the given operation. If you need to pass in a literal
string containing that prefix as an argument, you do that by constructing a new
<code>Constant</code>, like <code>new Constant("*x")</code>.</p>
</div>
<div class="paragraph">
<p>With this in mind, letâ€™s look at an example that has more nodes but that employs
only the concepts youâ€™ve learned so far:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Block.each(Ops.IDENTITY, <span class="hljs-string">"a"</span>).out(<span class="hljs-string">"*x"</span>)
     .each(Ops.IDENTITY, <span class="hljs-string">"b"</span>).out(<span class="hljs-string">"*y"</span>)
     .each(Ops.TO_STRING, <span class="hljs-string">"*x"</span>, <span class="hljs-string">"*y"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"!"</span>, <span class="hljs-number">2</span>).out(<span class="hljs-string">"*z"</span>)
     .each(Ops.PRINTLN, <span class="hljs-string">"*z"</span>)
     .execute();</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>This graph incrementally builds up values in the scope, and then creates a
combined value with <code>Ops.TO_STRING</code> thatâ€™s used to print the value <code>"ab1!2"</code>. Youâ€™ll be doing a
lot of this as you work with Rama.</p>
</div>
</div>
<div class="sect2">
<h3 id="_performance"><a class="anchor" href="#_performance"></a>Performance</h3>
<div class="paragraph">
<p>Rama compiles these dataflow graphs to very efficient bytecode. For example,
variables used in dataflow code become actual variables in bytecode, even though
they arenâ€™t defined using traditional Java syntax. Likewise, more advanced dataflow constructs like loops and conditionals also compile to very efficient bytecode.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_quick_aside_on_execute"><a class="anchor" href="#_a_quick_aside_on_execute"></a>A quick aside on <code>execute()</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>In real production code, you wonâ€™t use the <code>execute()</code> method. Weâ€™re only using
it here to synthetically send input events to a dataflow graphâ€™s root node. In
real code, youâ€™ll <em>source</em> data from data depots, like we did in previous
examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleWordCountModule</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RamaModule</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">define</span><span class="hljs-params">(Setup setup, Topologies topologies)</span> </span>{
        setup.declareDepot(<span class="hljs-string">"*wordDepot"</span>, Depot.random());
        StreamTopology s = topologies.stream(<span class="hljs-string">"wordCountStream"</span>);

        s.pstate(<span class="hljs-string">"$$wordCounts"</span>, PState.mapSchema(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Object</span>.<span class="hljs-title">class</span>))</span>;
        s.source(<span class="hljs-string">"*wordDepot"</span>).out(<span class="hljs-string">"*token"</span>)
         .hashPartition(<span class="hljs-string">"$$wordCounts"</span>, <span class="hljs-string">"*token"</span>)
         .compoundAgg(<span class="hljs-string">"$$wordCounts"</span>, CompoundAgg.map(<span class="hljs-string">"*token"</span>, Agg.count()));
    }
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>Here, the dataflow graphâ€™s root is a node created by <code>s.source("*wordDepot")</code>.
This node works by continually reading records from the <code>"*wordDepot"</code> depot and
emitting them.</p>
</div>
<div class="paragraph">
<p>With that explained letâ€™s return to constructing dataflow graphs:</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_branching_dataflow_graphs"><a class="anchor" href="#_branching_dataflow_graphs"></a>Branching dataflow graphs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Itâ€™s possible to create branching dataflow graphs, where a node A emits to nodes
B and C, and B and Câ€™s operations execute independently of each other. Itâ€™s also
possible to <em>unify</em> nodes, so that two or more nodes emit to the same node.</p>
</div>
<div class="paragraph">
<p>Doing this in Ramaâ€™s dataflow API is a little interesting because youâ€™re
building a 2-dimensional structure (the graph) using a 1-dimensional tool (a
sequence of dataflow API calls). Hereâ€™s a bare bones example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brancher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RamaOperation0</span> </span>{
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(OutputCollector collector)</span> </span>{
            collector.emitStream(<span class="hljs-string">"pizzaOrders"</span>, <span class="hljs-number">1</span>);
            collector.emitStream(<span class="hljs-string">"saladOrders"</span>, <span class="hljs-number">10</span>);
            collector.emitStream(<span class="hljs-string">"saladOrders"</span>, <span class="hljs-number">11</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unifyExample</span><span class="hljs-params">()</span> </span>{
        Block.each(<span class="hljs-keyword">new</span> Brancher()).outStream(<span class="hljs-string">"pizzaOrders"</span>, <span class="hljs-string">"pizzaAnchor1"</span>, <span class="hljs-string">"*pizzaOrderSize"</span>)
                                  .outStream(<span class="hljs-string">"saladOrders"</span>, <span class="hljs-string">"saladAnchor1"</span>, <span class="hljs-string">"*saladOrderSize"</span>)
             .each(Ops.DEC, <span class="hljs-string">"*saladOrderSize"</span>).out(<span class="hljs-string">"*orderSize"</span>)
             .anchor(<span class="hljs-string">"saladAnchor2"</span>)
             .hook(<span class="hljs-string">"pizzaAnchor1"</span>)
             .each(Ops.INC, <span class="hljs-string">"*pizzaOrderSize"</span>).out(<span class="hljs-string">"*orderSize"</span>)
             .anchor(<span class="hljs-string">"pizzaAnchor2"</span>)
             .unify(<span class="hljs-string">"pizzaAnchor2"</span>, <span class="hljs-string">"saladAnchor2"</span>)
             .each(Ops.PRINTLN, <span class="hljs-string">"*orderSize"</span>)
             .execute();
    }</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>This constructs a graph that looks like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/diagrams/dataflow-diagrams/unify-example.png" alt="unify example">
</div>
</div>
<div class="sect2">
<h3 id="_output_streams_hooks_anchors_and_unify"><a class="anchor" href="#_output_streams_hooks_anchors_and_unify"></a>Output streams, hooks, anchors, and unify</h3>
<div class="paragraph">
<p>Letâ€™s walk through code graph line by line to understand whatâ€™s happening.
First, we create an operation, <code>Brancher</code> (the next section goes into detail
about how to create operations).</p>
</div>
<div class="paragraph">
<p>The <code>Brancher</code> operation uses its <code>collector</code> argument to emit to two separate
<em>streams</em>, <code>"pizzaOrders"</code> and <code>"saladOrders"</code>. This is how you emit to
multiple outputs; you donâ€™t emit directly to another node as you donâ€™t know what the
other nodes are. Instead, you emit values by placing them in named streams, which
can be thought of as channels or sockets, and which can be visualized as the
arcs between dataflow nodes.</p>
</div>
<div class="paragraph">
<p>In fact, every other graph weâ€™ve constructed so far has emitted values to
streams and not directly to other nodes. We just havenâ€™t named those streams,
because we havenâ€™t needed to. In the absence of constructs like <code>emitStream()</code>
which allow you to specify a stream, nodes emit to what is called <em>the default
output stream</em>. As you add nodes, they implicitly take the most recently
constructed output stream as their input. Letâ€™s look at a previous example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Block.each(Ops.IDENTITY, <span class="hljs-string">"a"</span>).out(<span class="hljs-string">"*x"</span>)</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p><code>.each(Ops.IDENTITY, "a")</code> creates a node that emits the value <code>"a"</code>, but
doesnâ€™t specify which stream to emit to, so it emits to the default output
stream. The method call <code>.out("*x")</code> is chained to the return value of <code>each</code>,
and the Rama API interprets this as hooking up the default output stream of <code>each</code> to
<code>out</code>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/diagrams/dataflow-diagrams/default-output-stream.png" alt="default output stream">
</div>
</div>
<div class="paragraph">
<p>Back to our branching example. The method call <code>.each(new Brancher())</code> creates a
node whose operation is to emit values to two streams, <code>"pizzaOrders"</code> and
<code>"saladOrders"</code>. Next we need to create nodes to receive those values as
inputs, and thatâ€™s done with the calls to <code>.outStream("pizzaOrders",
"pizzaAnchor1", "*pizzaOrderSize")</code> and <code>.outStream("saladOrders",
"saladAnchor1", "*saladOrderSize")</code>. Like the <code>out</code> method, <code>outStream</code>
creates a node that creates a new scope binding; one of the nodes creates a
binding to <code>"*pizzaOrderSize"</code> and the other creates a binding to
<code>"*saladOrderSize"</code>. <code>.outStream()</code> differs from <code>.out()</code> in that you also
specify which stream is the input, and you specify the name for the node that
gets created. In <code>.outStream("pizzaOrders", "pizzaAnchor1",
"*pizzaOrderSize")</code>, <code>"pizzaOrders"</code> is the input stream and
<code>"pizzaAnchor1"</code> is the name for the node thatâ€™s created by this method call.</p>
</div>
<div class="paragraph">
<p>In Rama, names for nodes are called <em>anchors</em>. You name nodes when constructing
graphs with branches in order to specify which branch to add more streams and
nodes to. The above example branches into two streams, each connected to an
<code>outStream</code> node. The line <code>.each(Ops.DEC, "*saladOrderSize")</code> builds off of
the <code>outStream</code> node that precedes it â€“ in this case, <code>saladAnchor1</code></p>
</div>
<div class="paragraph">
<p>What if you want to build off <code>pizzaAnchor1</code>? This is where you have to deal
with the fact that the dataflow graph is two-dimensional, but our code is one-dimensional.
You use the <code>hook</code> method call to indicate that you want to start building off a
different node. Here, we use <code>hook("pizzaAnchor1")</code> to indicate that the
subgraph that follows should be attached to the node <code>pizzaAnchor1</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_unifying_dataflow_branches"><a class="anchor" href="#_unifying_dataflow_branches"></a>Unifying dataflow branches</h3>
<div class="paragraph">
<p>You can <em>unify</em> dataflow branches so they emit to the same node. There isnâ€™t any requirement
for you to unify output streams like this â€“ itâ€™s really up to you and what your application needs.
But when you <em>do</em> need it, hereâ€™s how it works:</p>
</div>
<div class="paragraph">
<p>First, in the example weâ€™ve been looking at each dataflow branch includes the method call <code>out("*orderSize")</code>,
creating <code>out</code> nodes.</p>
</div>
<div class="paragraph">
<p>Next, we name each of nodes branches with the <code>anchor()</code> method call. Whereas
the <code>outStream()</code> method lets you provide an anchor name for the node it
creates, the <code>anchor()</code> method call allows you to attach an anchor to the
node right before the call. Thus, the node for <code>out("*orderSize")</code> in the <code>"saladAnchor1"</code> branch
is named <code>"saladAnchor2"</code>, and likewise for the pizza branch.</p>
</div>
<div class="paragraph">
<p>After that, we use <code>unify("pizzaAnchor2", "saladAnchor2")</code> to create a new
node, with the nodes referenced as inputs. Each time either of those nodes emits
a value, then the <code>unify</code> node will receive it as input. It doesnâ€™t perform any
further operations and connects to the node for <code>each(Ops.PRINTLN, "*orderSize")</code>.</p>
</div>
<div class="paragraph">
<p>Note that the var <code>"*orderSize"</code> was defined in each of the unified
branches. A var is considered in scope after a unify if it
satisfies one of two conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It was in scope before the branch point of the unify tree</p>
</li>
<li>
<p>Itâ€™s defined on <strong>all branches</strong> of the unify tree</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>"*orderSize"</code> is defined in each branch of the unify tree, so itâ€™s available
after the unify node.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conditionals"><a class="anchor" href="#_conditionals"></a>Conditionals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can add conditionals to your dataflow graph, so that when the conditional is
true a provided sub-graph receives input. The following example shows how you
might check whether two numbers are equal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleConditionalExample</span><span class="hljs-params">()</span> </span>{
    Block.each(Ops.EQUAL, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>).out(<span class="hljs-string">"*condition"</span>)
         .ifTrue(<span class="hljs-string">"*condition"</span>,
           Block.each(Ops.PRINTLN, <span class="hljs-string">"math is dead!"</span>))
         .each(Ops.PRINTLN, <span class="hljs-string">"Conditional complete"</span>)
         .execute();
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>This creates a graph that looks like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/diagrams/dataflow-diagrams/conditional.png" alt="conditional">
</div>
</div>
<div class="paragraph">
<p>The method <code>ifTrue</code> here takes two arguments, a condition value and a block. It creates a
new node in the dataflow graph with two output streams; the node emits to the
<code>false</code> stream when the condition value is null or false, and <code>true</code> otherwise. The provided
block receives input from the <code>true</code> stream.</p>
</div>
<div class="paragraph">
<p>Note that thereâ€™s an implicit unification: both branches of the condition end up
emitting to the same node.</p>
</div>
<div class="paragraph">
<p>Usually you wouldnâ€™t bind an explicit var for the condition value, but you would nest an expression like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleConditionalExample</span><span class="hljs-params">()</span> </span>{
    Block.ifTrue(<span class="hljs-keyword">new</span> Expr(Ops.EQUAL, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
           Block.each(Ops.PRINTLN, <span class="hljs-string">"math is dead!"</span>))
         .each(Ops.PRINTLN, <span class="hljs-string">"Conditional complete"</span>)
         .execute();
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>This is equivalent to the previous example, and in fact behind the scenes compiles to the previous example. <code>Expr</code> can be used anywhere input arguments are taken and are useful for making the code more concise.</p>
</div>
<div class="paragraph">
<p>What if you want to include an <code>else</code> clause to a condition? To do that, you just pass in another block as the third argument to <code>ifTrue</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">twoConditionalsExample</span><span class="hljs-params">()</span> </span>{
    Block.ifTrue(<span class="hljs-keyword">new</span> Expr(Ops.EQUAL, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
           Block.each(Ops.PRINTLN, <span class="hljs-string">"math is dead!"</span>),
           Block.each(Ops.PRINTLN, <span class="hljs-string">"math is alive!"</span>))
         .each(Ops.PRINTLN, <span class="hljs-string">"conditional complete"</span>)
         .execute();
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>This produces a graph like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/diagrams/dataflow-diagrams/full-conditional.png" alt="full conditional">
</div>
</div>
<div class="paragraph">
<p>Again, thereâ€™s an implicit unification here. That means itâ€™s possible to
introduce new var bindings, but for those bindings to be accessible
post-unification, they must be present in each branch. So this code would fail to compile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidUnificationExample</span><span class="hljs-params">()</span> </span>{
    Block.ifTrue(<span class="hljs-keyword">new</span> Expr(Ops.EQUAL, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
           Block.each(Ops.IDENTITY, <span class="hljs-number">1</span>).out(<span class="hljs-string">"*a"</span>),
           Block.each(Ops.IDENTITY, <span class="hljs-number">2</span>).out(<span class="hljs-string">"*b"</span>))
         .each(Ops.PRINTLN, <span class="hljs-string">"*a"</span>)
         .execute();
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>But this code compiles fine because <code>"*a"</code> is available on both branches of the conditional:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validUnificationExample</span><span class="hljs-params">()</span> </span>{
    Block.ifTrue(<span class="hljs-keyword">new</span> Expr(Ops.EQUAL, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
           Block.each(Ops.IDENTITY, <span class="hljs-number">1</span>).out(<span class="hljs-string">"*a"</span>),
           Block.each(Ops.IDENTITY, <span class="hljs-number">2</span>).out(<span class="hljs-string">"*a"</span>))
         .each(Ops.PRINTLN, <span class="hljs-string">"*a"</span>)
         .execute();
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>Rama checks the scope of all vars when compiling a <code>Block</code> and will never execute code that has an invalid var reference.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_custom_operations"><a class="anchor" href="#_writing_custom_operations"></a>Writing custom operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that youâ€™ve looked at how to construct a dataflow graph, letâ€™s have a look at
how to write custom operations for nodes. There are two different kinds of
implementations for operations: <code>RamaFunction</code> and <code>RamaOperation</code>. Letâ€™s look
at an example of a <code>RamaFunction</code> first:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddTen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RamaFunction1</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Integer</span>&gt; </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">invoke</span><span class="hljs-params">(Integer l)</span> </span>{
        <span class="hljs-keyword">return</span> l + <span class="hljs-number">10</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ramaFunctionExample</span><span class="hljs-params">()</span> </span>{
    Block.each(<span class="hljs-keyword">new</span> AddTen(), <span class="hljs-number">1</span>).out(<span class="hljs-string">"*numberPlusTen"</span>)
         .each(Ops.PRINTLN, <span class="hljs-string">"*numberPlusTen"</span>)
         .execute()
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>Of note:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AddTen</code> is a public static class with a single public method, <code>invoke</code>.</p>
</li>
<li>
<p>It extends <code>RamaFunction1</code>. The 1 designates how many arguments this operation
takes; thereâ€™s also <code>RamaFunction0</code> all the way through <code>RamaFunction8</code>.</p>
</li>
<li>
<p><code>each</code> will call <code>invoke</code>, passing in whatever additional arguments you pass
to <code>each</code></p>
</li>
<li>
<p><code>invoke</code> will <code>return</code> a value, and that value is emitted to the default
output stream.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>RamaFunction</code> is the simpler, stripped-down implementation of operations. When
you implement a <code>RamaFunction</code>, your <code>invoke</code> method should always return a
value. And whereas <code>RamaOperation</code> implementations can emit multiple times and
to multiple streams, a <code>RamaFunction</code> can only emit once. You should prefer a
<code>RamaFunction</code> where possible because itâ€™s more efficient. Itâ€™s also more
concise in that you donâ€™t need to use an <code>OutputCollector</code>.</p>
</div>
<div class="paragraph">
<p>A <code>RamaOperation</code> is more general than a <code>RamaFunction</code>, capable of emitting multiple times, doing work between emits, emitting to multiple streams, and emitting multiple fields in a single emit. Hereâ€™s an example demonstrating all of this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOperation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RamaOperation0</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(OutputCollector collector)</span> </span>{
        <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;
        collector.emitStream(<span class="hljs-string">"streamA"</span>, x);
        <span class="hljs-keyword">int</span> y = x + <span class="hljs-number">2</span>;
        collector.emit(x, y, <span class="hljs-string">"s"</span>);
        collector.emitStream(<span class="hljs-string">"streamB"</span>);
    }
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>This function could be invoked in dataflow code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Block.each(<span class="hljs-keyword">new</span> MyOperation()).outStream(<span class="hljs-string">"streamA"</span>, <span class="hljs-string">"anchorA"</span>, <span class="hljs-string">"*v1"</span>)
                             .outStream(<span class="hljs-string">"streamB"</span>, <span class="hljs-string">"anchorB"</span>)
                             .out(<span class="hljs-string">"*a"</span>, <span class="hljs-string">"*b"</span>, <span class="hljs-string">"*c"</span>)</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>Here, <code>MyOperation</code> is implementing <code>RamaOperation0</code>, indicating it takes zero
arguments. And yet, <code>invoke</code> takes an argument, <code>OutputCollector collector</code>.
This is the object you use to emit arbitrary values to arbitrary streams, and you
can see in the example we do indeed emit to three streams, taking in various amounts of values as input. When invoking a <code>RamaOperation</code> via the dataflow API, itâ€™s important when using <code>out</code> or <code>outStream</code> you capture exactly the number of values
emitted. Just like how you must call methods in Java with the correct number of input arguments, you must capture the outputs of Rama with the correct number of output bindings.</p>
</div>
<div class="paragraph">
<p>When a <code>RamaOperation</code> emits, the code connected to the corresponding <code>outStream</code> or <code>out</code> is executed immediately. Control flow returns back into the <code>RamaOperation</code> only when that downstream code finishes executing.</p>
</div>
<div class="paragraph">
<p>Another way to write custom operations is to use lambdas. You could rewrite the
<code>ramaFunctionExample</code> above like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ramaFunctionExample</span><span class="hljs-params">()</span> </span>{
    Block.each((Integer l) -&gt; l + <span class="hljs-number">10</span>, <span class="hljs-number">1</span>).out(<span class="hljs-string">"*numberPlusTen"</span>)
         .each(Ops.PRINTLN, <span class="hljs-string">"*numberPlusTen"</span>)
         .execute()
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>Yet another approach is to use method references:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ramaFunctionExample</span><span class="hljs-params">()</span> </span>{
    Block.each(Math::abs, <span class="hljs-number">1.2</span>).out(<span class="hljs-string">"*absoluteValue"</span>)
         .each(Ops.PRINTLN, <span class="hljs-string">"*absoluteValue"</span>)
         .execute()
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>Method references are nice because they can be used from other Java code as well
as directly in topologies. Lambdas and method references are less verbose than a <code>RamaFunction</code>
and are generally preferred.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_immutable_scope_and_shadowing"><a class="anchor" href="#_immutable_scope_and_shadowing"></a>Immutable scope and shadowing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Because scope bindings can be emitted to multiple nodes, you might be wondering
if itâ€™s possible for one node to change another nodeâ€™s bindings.</p>
</div>
<div class="paragraph">
<p>Good news: <em>scope bindings are immutable</em>. When a node emits a scope, nothing
can change it between the time itâ€™s emitted and the time itâ€™s received as input
by its child nodes. Even if you create a new binding with the same name, that
creates a new immutable scope and doesnâ€™t affect other scopes. This example
demonstrates this idea:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
  <span class="hljs-keyword">public</span> String name;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>{
    <span class="hljs-keyword">this</span>.name = name;
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiOut</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RamaOperation0</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(OutputCollector collector)</span> </span>{
        collector.emitStream(<span class="hljs-string">"stream1"</span>);
        collector.emitStream(<span class="hljs-string">"stream2"</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shadowExample</span><span class="hljs-params">()</span> </span>{
    Block.each(Ops.IDENTITY, <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Megan"</span>)).out(<span class="hljs-string">"*person"</span>)
            .each(<span class="hljs-keyword">new</span> MultiOut()).outStream(<span class="hljs-string">"stream1"</span>, <span class="hljs-string">"stream1Anchor"</span>)
                                 .outStream(<span class="hljs-string">"stream2"</span>, <span class="hljs-string">"stream2Anchor"</span>)
            .each(Ops.IDENTITY, <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"John"</span>)).out(<span class="hljs-string">"*person"</span>)
            .hook(<span class="hljs-string">"stream1Anchor"</span>)
            .each((Person person) -&gt; person.name).out(<span class="hljs-string">"*personName"</span>)
            .each(Ops.PRINTLN, <span class="hljs-string">"*personName"</span>)
            .execute();
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shadowMutationExample</span><span class="hljs-params">()</span> </span>{
    Block.each(Ops.IDENTITY, <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Megan"</span>)).out(<span class="hljs-string">"*person"</span>)
            .each(<span class="hljs-keyword">new</span> MultiOut()).outStream(<span class="hljs-string">"stream1"</span>, <span class="hljs-string">"stream1Anchor"</span>)
                                 .outStream(<span class="hljs-string">"stream2"</span>, <span class="hljs-string">"stream2Anchor"</span>)
            .each((Person person) -&gt; {
              person.name = <span class="hljs-string">"John"</span>;
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
            })
            .hook(<span class="hljs-string">"stream1Anchor"</span>)
            .each((Person person) -&gt; person.name).out(<span class="hljs-string">"*name"</span>)
            .each(Ops.PRINTLN, <span class="hljs-string">"*name"</span>)
            .execute();
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>The <code>MultiOut</code> operation emits to two separate streams. It also implicitly emits its scope, which includes a binding for <code>"*person"</code>.</p>
</div>
<div class="paragraph">
<p>In <code>shadowExample</code>, the <code>"stream2"</code> branch creates a new <code>Person</code> and binds that
object to the name <code>"*person"</code>. This will never affect the binding in
<code>"stream1"</code>; <code>"stream1"</code> will always print <code>"Megan"</code>.</p>
</div>
<div class="paragraph">
<p>In <code>shadowMutationExample</code>, however, the <code>"stream2"</code> branch actually mutates the
shared object that happens to be bound to <code>*person</code> in both branches. In this
case, itâ€™s possible for <code>"stream1"</code> to print <code>"John"</code>, depending on the order in
which the branches are executed. In this case, because <code>MultiOut</code> emits to <code>"stream1"</code> first, it will print <code>"Megan"</code>. If <code>MultiOut</code> were changed to emit to <code>"stream2"</code> first, it would print <code>"John"</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_looping"><a class="anchor" href="#_looping"></a>Looping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ramaâ€™s dataflow API also includes a looping construct. In fact, because Ramaâ€™s dataflow API has both condition and looping constructs, it is Turing-complete. Hereâ€™s an example of looping in Rama:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loopExample</span><span class="hljs-params">()</span> </span>{
    Block.loopWithVars(LoopVars.<span class="hljs-keyword">var</span>(<span class="hljs-string">"*i"</span>, <span class="hljs-number">0</span>),
      Block.ifTrue(<span class="hljs-keyword">new</span> Expr(Ops.NOT_EQUAL, <span class="hljs-string">"*i"</span>, <span class="hljs-number">5</span>),
        Block.emitLoop(<span class="hljs-string">"*i"</span>)
             .each(Ops.PRINTLN, <span class="hljs-string">"Variable *i is not 5 yet"</span>)
             .continueLoop(<span class="hljs-keyword">new</span> Expr(Ops.INC, <span class="hljs-string">"*i"</span>)))).out(<span class="hljs-string">"*loopValue"</span>)
      .each(Ops.PRINTLN, <span class="hljs-string">"Emitted:"</span>, <span class="hljs-string">"*loopValue"</span>)
      .execute();
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>This prints out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Emitted: 0
Variable *i is not 5 yet
Emitted: 1
Variable *i is not 5 yet
Emitted: 2
Variable *i is not 5 yet
Emitted: 3
Variable *i is not 5 yet
Emitted: 4
Variable *i is not 5 yet</code></pre>
<div class="source-toolbox"><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>Here is the graph it produces:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/diagrams/dataflow-diagrams/looping.png" alt="looping">
</div>
</div>
<div class="paragraph">
<p>This looks somewhat similar to the conditional graph you just saw. <code>loopWithVars</code>
creates a node, which weâ€™ll call the <em>loop root</em>. When it emits, its scope
includes an initial binding for the var <code>"*i"</code>. It emits to an <code>ifTrue</code> node which checks a base
condition for whether to execute an iteration of the loop.</p>
</div>
<div class="paragraph">
<p>The loopâ€™s control flow is implemented with <code>continueLoop</code> and <code>emitLoop</code>.
<code>continueLoop</code> creates a new node that emits a value to the node loop root. The
loop root uses this to kick off a new loop iteration, binding <code>"*i"</code> to the
value it receives as input from <code>continueLoop</code>. Thus the initial execution of
the loop has <code>"*i"</code> bound to the number <code>0</code>, and the next execution has <code>"*i"</code> bound
to <code>1</code> and so on until the value of <code>"*i"</code> is <code>5</code>.</p>
</div>
<div class="paragraph">
<p>When <code>emitLoop</code> is called, flow control immediately goes to the <code>out("*loopValue")</code> node and what follows from that. When that branch of code finishes, flow control goes back to the next node after <code>emitLoop</code>. Think of what comes after the loop as a function that <code>emitLoop</code> calls (this is formally known as the loopâ€™s "continuation"). If you have multiple <code>emitLoop</code> nodes in a loop, they will all emit to the same <code>loopEmitter</code> node, and whatever <code>loopEmitter</code> receives as input it then executes the following node.</p>
</div>
<div class="paragraph">
<p>The way to execute another iteration of a loop is to call <code>continueLoop</code> with the new values for the loop vars. This example executes the loop body five times. If <code>continueLoop</code> is not called, execution of the loop stops.</p>
</div>
<div class="paragraph">
<p>Note that these semantics are different than what youâ€™re used to from looping constructs in languages like Java, where control flow moves past a loop once the loop finishes. In Rama, control flow moves past the loop only when <code>emitLoop</code> is called and this is before the loop has finished executing. A loop finishing in Rama <em>does not</em> move control flow past the loop.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_looping_without_vars"><a class="anchor" href="#_looping_without_vars"></a>Looping without vars</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Thereâ€™s another dataflow method <code>loop</code> that works exactly like <code>loopWithVars</code> but doesnâ€™t require a var declaration. When using this construct you would generally determine whether to continue looping based on some mutable state bound before the loop. Hereâ€™s an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loopExample</span><span class="hljs-params">()</span> </span>{
    Block.each((RamaFunction0) ArrayList::<span class="hljs-keyword">new</span>).out(<span class="hljs-string">"*list"</span>)
         .loop(
           Block.each(Ops.SIZE, <span class="hljs-string">"*list"</span>).out(<span class="hljs-string">"*size"</span>)
               .ifTrue(<span class="hljs-keyword">new</span> Expr(Ops.EQUAL, <span class="hljs-string">"*size"</span>, <span class="hljs-number">3</span>),
                 Block.emitLoop(),
                 Block.each((List l) -&gt; l.add(<span class="hljs-string">"iter"</span>), <span class="hljs-string">"*list"</span>)
                      .continueLoop()))
      .each(Ops.PRINTLN, <span class="hljs-string">"Result:"</span>, <span class="hljs-string">"*list"</span>)
      .execute();
}</code></pre>
<div class="source-toolbox"><span class="source-lang">java</span><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>This prints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Result: #object[java.util.ArrayList 0x68b4eba7 [iter, iter, iter]]</code></pre>
<div class="source-toolbox"><button class="copy-button" title="Copy to clipboard"><img src="../../_/img/octicons-16.svg#view-clippy" alt="copy icon" class="copy-icon"><span class="copy-toast">Copied!</span></button></div></div>
</div>
<div class="paragraph">
<p>Note here thereâ€™s no <code>out</code> attached to the <code>loop</code> call â€“&nbsp;Rama inserts that implicitly when itâ€™s not provided.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_summary"><a class="anchor" href="#_summary"></a>Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, you learned the basics of dataflow programming. Ramaâ€™s dataflow API is expressive and flexible, giving you precise control over how data is processed and how logic branches and merges.</p>
</div>
<div class="paragraph">
<p>There are more dataflow features in the Rama API that werenâ€™t covered in this section. These include batch computation (e.g. joins, aggregation) and facilities for separating dataflow code into reusable chunks. These features and more are covered in <a href="intermediate-dataflow.html" class="page">Intermediate dataflow programming</a>.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
</footer>
<script type="text/javascript" src="../../_/js/main.js"></script>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async="" src="../../_/js/vendor/highlight.js"></script>
  

<table cellspacing="0" cellpadding="0" role="presentation" class="gstl_50 gssb_c" style="width: 217px; display: none; top: 50px; left: 1048px; position: absolute;"><tbody><tr><td class="gssb_f"></td><td class="gssb_e" style="width: 100%;"></td></tr></tbody></table></body></html>